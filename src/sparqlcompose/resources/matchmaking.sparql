@prefix sd:    <http://www.w3.org/ns/sparql-service-description#>.
@prefix shacl: <http://www.w3.org/ns/shacl#>.
@prefix sp:    <http://spinrdf.org/sp#> .
@prefix sms:   <http://sms.i3s.unice.fr/terms/>

INSERT {
    GRAPH <{MatchmakingGraph}>
    {
        ?service a sd:Service;
          sms:elements [
            sp:subject ?s; sp:object ?o; sp:predicate ?p;
            sms:optionalNode ?optional;   # the OPTIONAL node that contains the triple pattern
          ].
        ?s sp:varName ?varNameS.
        ?p sp:varName ?varNameP.
        ?o sp:varName ?varNameO.
    }
}
WHERE {
    # Get each triple pattern from the client query and optional variable names for each term
    GRAPH <{SpinQueryGraph}>
    {
        ?triple sp:subject ?s; sp:predicate ?p; sp:object ?o.
        OPTIONAL { ?s sp:varName ?varNameS. }
        OPTIONAL { ?p sp:varName ?varNameP. }
        OPTIONAL { ?o sp:varName ?varNameO. }

        # Check whether the triple pattern is embedded in an sp:Optional node
        OPTIONAL { ?optional a sp:Optional; sp:elements/(rdf:rest|rdf:first)* ?triple. }
    }
    
    # Check the triple pattern against each node shape of each service
    ?service a sd:Service; sd:defaultDataset [ sd:defaultGraph [ shacl:shapesGraph ?shapesGraph ]].

    # Verify that the triple pattern matches the node shape definition
    FILTER sms:validate(?s, ?p, ?o, ?shapesGraph)
}

# Checks whether the given triple pattern is valid wrt. the given shapes graph
function sms:validate(?s, ?p, ?o, ?shapesGraph) {
  EXISTS {
    GRAPH <{SpinQueryGraph}>
    {
        # Force the evaluation of variables so that they be bound with the value of parameter with the same name
        [] sp:subject ?s; sp:predicate ?p; sp:object ?o.
        OPTIONAL { ?o sp:varName ?varNameO. }
        
        # Check whether ?s is the object in a "parent" triple pattern
        OPTIONAL { [] sp:subject ?s2; sp:predicate ?p2; sp:object ?s. }
    }
    
    GRAPH ?shapesGraph {
      ?nodeShape shacl:property ?propShape.
      ?propShape shacl:path ?p.
      OPTIONAL { ?propShape shacl:nodeKind ?nodeType. }
      OPTIONAL { ?propShape shacl:hasValue ?nodeValue. }
      OPTIONAL { ?propShape shacl:node     ?subseqNodeShape. }
    }

    FILTER (
      # If "?s ?p ?o" has a parent triple, then this parent triple must also be valid wrt to the shapes graph
      if (bound(?s2) && bound(?p2), sms:validate(?s2, ?p2, ?s, ?shapesGraph), true)
      &&
      (
        # If the shape has a node type, ?o must comply with that type unless it is a variable
        bound(?nodeType) &&
          (bound(?varNameO) || (?nodeType = shacl:Literal && isLiteral(?o)) || (?nodeType = shacl:IRI && isIRI(?o)))
        ||
        # ?o has a fixed value in the shape.
        bound(?nodeValue) && (bound(?varNameO) || (?o = ?nodeValue))
        ||
        # ?o corresponds to a ShapeNode. Triples with ?o as their subject may or may not 
        # be valid with respect to the same shapes node.
        bound(?subseqNodeShape)
      )
    )
  }
}
